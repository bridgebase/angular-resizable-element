{
  "version": 3,
  "file": "angular-resizable-element.umd.min.js",
  "sources": [
    "ng://angular-resizable-element/src/resizable.directive.ts",
    "ng://angular-resizable-element/src/resize-handle.directive.ts",
    "ng://angular-resizable-element/src/resizable.module.ts"
  ],
  "sourcesContent": [
    "import {\n  Directive,\n  Renderer2,\n  ElementRef,\n  OnInit,\n  Output,\n  Input,\n  EventEmitter,\n  OnDestroy,\n  NgZone\n} from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport { Observable } from 'rxjs/Observable';\nimport { Observer } from 'rxjs/Observer';\nimport { merge } from 'rxjs/observable/merge';\nimport { interval } from 'rxjs/observable/interval';\nimport { map } from 'rxjs/operators/map';\nimport { mergeMap } from 'rxjs/operators/mergeMap';\nimport { takeUntil } from 'rxjs/operators/takeUntil';\nimport { filter } from 'rxjs/operators/filter';\nimport { pairwise } from 'rxjs/operators/pairwise';\nimport { take } from 'rxjs/operators/take';\nimport { throttle } from 'rxjs/operators/throttle';\nimport { share } from 'rxjs/operators/share';\nimport { Edges } from './interfaces/edges.interface';\nimport { BoundingRectangle } from './interfaces/bounding-rectangle.interface';\nimport { ResizeEvent } from './interfaces/resize-event.interface';\n\ninterface PointerEventCoordinate {\n  clientX: number;\n  clientY: number;\n  event: MouseEvent | TouchEvent;\n}\n\ninterface Coordinate {\n  x: number;\n  y: number;\n}\n\nfunction isNumberCloseTo(\n  value1: number,\n  value2: number,\n  precision: number = 3\n): boolean {\n  const diff: number = Math.abs(value1 - value2);\n  return diff < precision;\n}\n\nfunction getNewBoundingRectangle(\n  startingRect: BoundingRectangle,\n  edges: Edges,\n  clientX: number,\n  clientY: number\n): BoundingRectangle {\n  const newBoundingRect: BoundingRectangle = {\n    top: startingRect.top,\n    bottom: startingRect.bottom,\n    left: startingRect.left,\n    right: startingRect.right\n  };\n\n  if (edges.top) {\n    newBoundingRect.top += clientY;\n  }\n  if (edges.bottom) {\n    newBoundingRect.bottom += clientY;\n  }\n  if (edges.left) {\n    newBoundingRect.left += clientX;\n  }\n  if (edges.right) {\n    newBoundingRect.right += clientX;\n  }\n  newBoundingRect.height = newBoundingRect.bottom - newBoundingRect.top;\n  newBoundingRect.width = newBoundingRect.right - newBoundingRect.left;\n\n  return newBoundingRect;\n}\n\nfunction getElementRect(\n  element: ElementRef,\n  ghostElementPositioning: string,\n  scaledParent?: HTMLDivElement,\n  scale = 1.0\n): BoundingRectangle {\n  let translateX = 0;\n  let translateY = 0;\n  const style = element.nativeElement.style;\n  const transformProperties = [\n    'transform',\n    '-ms-transform',\n    '-moz-transform',\n    '-o-transform'\n  ];\n  const transform = transformProperties\n    .map(property => style[property])\n    .find(value => !!value);\n  if (transform && transform.includes('translate')) {\n    translateX = transform.replace(/.*translate\\((.*)px, (.*)px\\).*/, '$1');\n    translateY = transform.replace(/.*translate\\((.*)px, (.*)px\\).*/, '$2');\n  }\n\n  if (ghostElementPositioning === 'absolute') {\n    return {\n      height: element.nativeElement.offsetHeight,\n      width: element.nativeElement.offsetWidth,\n      top: element.nativeElement.offsetTop - translateY,\n      bottom:\n        element.nativeElement.offsetHeight +\n        element.nativeElement.offsetTop -\n        translateY,\n      left: element.nativeElement.offsetLeft - translateX,\n      right:\n        element.nativeElement.offsetWidth +\n        element.nativeElement.offsetLeft -\n        translateX\n    };\n  } else {\n    const boundingClientRect = element.nativeElement.getBoundingClientRect();\n    let boundingRect: ClientRect;\n    if (scale !== 1.0) {\n      if (scaledParent) {\n        const parentClientRect = scaledParent.getBoundingClientRect();\n        boundingRect = {\n          bottom:\n            (boundingClientRect.bottom - parentClientRect.top) * 1 / scale,\n          top: (boundingClientRect.top - parentClientRect.top) * 1 / scale,\n          left: (boundingClientRect.left - parentClientRect.left) * 1 / scale,\n          right: (boundingClientRect.right - parentClientRect.left) * 1 / scale,\n          width: boundingClientRect.width * 1 / scale,\n          height: boundingClientRect.height * 1 / scale\n        };\n      } else {\n        // Allow consumers who's scaled ancestor is at 0,0 avoid passing it in\n        boundingRect = {\n          bottom: boundingClientRect.bottom * 1 / scale,\n          top: boundingClientRect.top * 1 / scale,\n          left: boundingClientRect.left * 1 / scale,\n          right: boundingClientRect.right * 1 / scale,\n          width: boundingClientRect.width * 1 / scale,\n          height: boundingClientRect.height * 1 / scale\n        };\n      }\n    } else {\n      boundingRect = boundingClientRect;\n    }\n    return {\n      height: boundingRect.height,\n      width: boundingRect.width,\n      top: boundingRect.top - translateY,\n      bottom: boundingRect.bottom - translateY,\n      left: boundingRect.left - translateX,\n      right: boundingRect.right - translateX,\n      scrollTop: element.nativeElement.scrollTop,\n      scrollLeft: element.nativeElement.scrollLeft\n    };\n  }\n}\n\nfunction isWithinBoundingY({\n  clientY,\n  rect\n}: {\n  clientY: number;\n  rect: ClientRect;\n}): boolean {\n  return clientY >= rect.top && clientY <= rect.bottom;\n}\n\nfunction isWithinBoundingX({\n  clientX,\n  rect\n}: {\n  clientX: number;\n  rect: ClientRect;\n}): boolean {\n  return clientX >= rect.left && clientX <= rect.right;\n}\n\nfunction getResizeEdges({\n  clientX,\n  clientY,\n  elm,\n  allowedEdges,\n  cursorPrecision\n}: {\n  clientX: number;\n  clientY: number;\n  elm: ElementRef;\n  allowedEdges: Edges;\n  cursorPrecision: number;\n}): Edges {\n  const elmPosition: ClientRect = elm.nativeElement.getBoundingClientRect();\n  const edges: Edges = {};\n\n  if (\n    allowedEdges.left &&\n    isNumberCloseTo(clientX, elmPosition.left, cursorPrecision) &&\n    isWithinBoundingY({ clientY, rect: elmPosition })\n  ) {\n    edges.left = true;\n  }\n\n  if (\n    allowedEdges.right &&\n    isNumberCloseTo(clientX, elmPosition.right, cursorPrecision) &&\n    isWithinBoundingY({ clientY, rect: elmPosition })\n  ) {\n    edges.right = true;\n  }\n\n  if (\n    allowedEdges.top &&\n    isNumberCloseTo(clientY, elmPosition.top, cursorPrecision) &&\n    isWithinBoundingX({ clientX, rect: elmPosition })\n  ) {\n    edges.top = true;\n  }\n\n  if (\n    allowedEdges.bottom &&\n    isNumberCloseTo(clientY, elmPosition.bottom, cursorPrecision) &&\n    isWithinBoundingX({ clientX, rect: elmPosition })\n  ) {\n    edges.bottom = true;\n  }\n\n  return edges;\n}\n\nexport interface ResizeCursors {\n  topLeft: string;\n  topRight: string;\n  bottomLeft: string;\n  bottomRight: string;\n  leftOrRight: string;\n  topOrBottom: string;\n}\n\nconst DEFAULT_RESIZE_CURSORS: ResizeCursors = Object.freeze({\n  topLeft: 'nw-resize',\n  topRight: 'ne-resize',\n  bottomLeft: 'sw-resize',\n  bottomRight: 'se-resize',\n  leftOrRight: 'ew-resize',\n  topOrBottom: 'ns-resize'\n});\n\nfunction getResizeCursor(edges: Edges, cursors: ResizeCursors): string {\n  if (edges.left && edges.top) {\n    return cursors.topLeft;\n  } else if (edges.right && edges.top) {\n    return cursors.topRight;\n  } else if (edges.left && edges.bottom) {\n    return cursors.bottomLeft;\n  } else if (edges.right && edges.bottom) {\n    return cursors.bottomRight;\n  } else if (edges.left || edges.right) {\n    return cursors.leftOrRight;\n  } else if (edges.top || edges.bottom) {\n    return cursors.topOrBottom;\n  } else {\n    return '';\n  }\n}\n\nfunction getEdgesDiff({\n  edges,\n  initialRectangle,\n  newRectangle\n}: {\n  edges: Edges;\n  initialRectangle: BoundingRectangle;\n  newRectangle: BoundingRectangle;\n}): Edges {\n  const edgesDiff: Edges = {};\n  Object.keys(edges).forEach((edge: string) => {\n    const typedEdge: keyof Edges = edge as keyof Edges;\n    edgesDiff[typedEdge] =\n      newRectangle[typedEdge] - initialRectangle[typedEdge];\n  });\n  return edgesDiff;\n}\n\nconst RESIZE_ACTIVE_CLASS: string = 'resize-active';\nconst RESIZE_LEFT_HOVER_CLASS: string = 'resize-left-hover';\nconst RESIZE_RIGHT_HOVER_CLASS: string = 'resize-right-hover';\nconst RESIZE_TOP_HOVER_CLASS: string = 'resize-top-hover';\nconst RESIZE_BOTTOM_HOVER_CLASS: string = 'resize-bottom-hover';\nconst RESIZE_GHOST_ELEMENT_CLASS: string = 'resize-ghost-element';\n\nexport const MOUSE_MOVE_THROTTLE_MS: number = 50;\n\n/**\n * Place this on an element to make it resizable. For example:\n *\n * ```html\n * <div\n *   mwlResizable\n *   [resizeEdges]=\"{bottom: true, right: true, top: true, left: true}\"\n *   [enableGhostResize]=\"true\">\n * </div>\n * ```\n */\n@Directive({\n  selector: '[mwlResizable]'\n})\nexport class ResizableDirective implements OnInit, OnDestroy {\n  /**\n   * A function that will be called before each resize event. Return `true` to allow the resize event to propagate or `false` to cancel it\n   */\n  @Input() validateResize: (resizeEvent: ResizeEvent) => boolean;\n\n  /**\n   * The edges that an element can be resized from. Pass an object like `{top: true, bottom: false}`. By default no edges can be resized.\n   */\n  @Input() resizeEdges: Edges = {};\n\n  /**\n   * Set to `true` to enable a temporary resizing effect of the element in between the `resizeStart` and `resizeEnd` events.\n   */\n  @Input() enableGhostResize: boolean = false;\n\n  /**\n   * A snap grid that resize events will be locked to.\n   *\n   * e.g. to only allow the element to be resized every 10px set it to `{left: 10, right: 10}`\n   */\n  @Input() resizeSnapGrid: Edges = {};\n\n  /**\n   * The mouse cursors that will be set on the resize edges\n   */\n  @Input() resizeCursors: ResizeCursors = DEFAULT_RESIZE_CURSORS;\n\n  /**\n   * Mouse over thickness to active cursor.\n   */\n  @Input() resizeCursorPrecision: number = 3;\n\n  /**\n   * Define the positioning of the ghost element (can be fixed or absolute)\n   */\n  @Input() ghostElementPositioning: 'fixed' | 'absolute' = 'fixed';\n\n  /**\n   * Define a scale transform of an ancestor element\n   */\n  @Input() scale: number = 1.0;\n\n  /**\n   * A reference to the HTMLElement ancestor element\n   */\n  @Input() scaledParent: HTMLDivElement;\n\n  /**\n   * Called when the mouse is pressed and a resize event is about to begin. `$event` is a `ResizeEvent` object.\n   */\n  @Output() resizeStart = new EventEmitter<ResizeEvent>();\n\n  /**\n   * Called as the mouse is dragged after a resize event has begun. `$event` is a `ResizeEvent` object.\n   */\n  @Output() resizing = new EventEmitter<ResizeEvent>();\n\n  /**\n   * Called after the mouse is released after a resize event. `$event` is a `ResizeEvent` object.\n   */\n  @Output() resizeEnd = new EventEmitter<ResizeEvent>();\n\n  /**\n   * @hidden\n   */\n  public mouseup = new Subject<{\n    clientX: number;\n    clientY: number;\n    edges?: Edges;\n  }>();\n\n  /**\n   * @hidden\n   */\n  public mousedown = new Subject<{\n    clientX: number;\n    clientY: number;\n    edges?: Edges;\n  }>();\n\n  /**\n   * @hidden\n   */\n  public mousemove = new Subject<{\n    clientX: number;\n    clientY: number;\n    edges?: Edges;\n    event: MouseEvent | TouchEvent;\n  }>();\n\n  private pointerEventListeners: PointerEventListeners;\n\n  private pointerEventListenerSubscriptions: any = {};\n\n  /**\n   * @hidden\n   */\n  constructor(\n    private renderer: Renderer2,\n    public elm: ElementRef,\n    private zone: NgZone\n  ) {\n    this.pointerEventListeners = PointerEventListeners.getInstance(\n      renderer,\n      zone\n    );\n  }\n\n  /**\n   * @hidden\n   */\n  ngOnInit(): void {\n    // TODO - use some fancy Observable.merge's for this\n    this.pointerEventListenerSubscriptions.pointerDown = this.pointerEventListeners.pointerDown.subscribe(\n      ({ clientX, clientY }) => {\n        this.mousedown.next({ clientX, clientY });\n      }\n    );\n\n    this.pointerEventListenerSubscriptions.pointerMove = this.pointerEventListeners.pointerMove.subscribe(\n      ({ clientX, clientY, event }) => {\n        this.mousemove.next({ clientX, clientY, event });\n      }\n    );\n\n    this.pointerEventListenerSubscriptions.pointerUp = this.pointerEventListeners.pointerUp.subscribe(\n      ({ clientX, clientY }) => {\n        this.mouseup.next({ clientX, clientY });\n      }\n    );\n\n    let currentResize: {\n      edges: Edges;\n      startingRect: BoundingRectangle;\n      currentRect: BoundingRectangle;\n      clonedNode?: HTMLElement;\n    } | null;\n\n    const removeGhostElement = () => {\n      if (currentResize && currentResize.clonedNode) {\n        this.elm.nativeElement.parentElement.removeChild(\n          currentResize.clonedNode\n        );\n        this.renderer.setStyle(this.elm.nativeElement, 'visibility', 'inherit');\n      }\n    };\n\n    const mouseMove: Observable<any> = this.mousemove.pipe(share());\n\n    mouseMove.pipe(filter(() => !!currentResize)).subscribe(({ event }) => {\n      event.preventDefault();\n    });\n\n    mouseMove\n      .pipe(throttle(() => interval(MOUSE_MOVE_THROTTLE_MS)))\n      .subscribe(({ clientX, clientY }) => {\n        const resizeEdges: Edges = getResizeEdges({\n          clientX,\n          clientY,\n          elm: this.elm,\n          allowedEdges: this.resizeEdges,\n          cursorPrecision: this.resizeCursorPrecision\n        });\n        const resizeCursors: ResizeCursors = Object.assign(\n          {},\n          DEFAULT_RESIZE_CURSORS,\n          this.resizeCursors\n        );\n        if (currentResize) {\n          const cursor: string = getResizeCursor(\n            currentResize.edges,\n            resizeCursors\n          );\n          this.renderer.setStyle(document.body, 'cursor', cursor);\n        } else {\n          const cursor: string = getResizeCursor(resizeEdges, resizeCursors);\n          this.renderer.setStyle(this.elm.nativeElement, 'cursor', cursor);\n        }\n        this.setElementClass(this.elm, RESIZE_ACTIVE_CLASS, !!currentResize);\n        this.setElementClass(\n          this.elm,\n          RESIZE_LEFT_HOVER_CLASS,\n          resizeEdges.left === true\n        );\n        this.setElementClass(\n          this.elm,\n          RESIZE_RIGHT_HOVER_CLASS,\n          resizeEdges.right === true\n        );\n        this.setElementClass(\n          this.elm,\n          RESIZE_TOP_HOVER_CLASS,\n          resizeEdges.top === true\n        );\n        this.setElementClass(\n          this.elm,\n          RESIZE_BOTTOM_HOVER_CLASS,\n          resizeEdges.bottom === true\n        );\n      });\n\n    const mousedrag: Observable<any> = this.mousedown\n      .pipe(\n        mergeMap(startCoords => {\n          function getDiff(moveCoords: { clientX: number; clientY: number }) {\n            return {\n              clientX: moveCoords.clientX - startCoords.clientX,\n              clientY: moveCoords.clientY - startCoords.clientY\n            };\n          }\n\n          const getSnapGrid = () => {\n            const snapGrid: Coordinate = { x: 1, y: 1 };\n\n            if (currentResize) {\n              if (this.resizeSnapGrid.left && currentResize.edges.left) {\n                snapGrid.x = +this.resizeSnapGrid.left;\n              } else if (\n                this.resizeSnapGrid.right &&\n                currentResize.edges.right\n              ) {\n                snapGrid.x = +this.resizeSnapGrid.right;\n              }\n\n              if (this.resizeSnapGrid.top && currentResize.edges.top) {\n                snapGrid.y = +this.resizeSnapGrid.top;\n              } else if (\n                this.resizeSnapGrid.bottom &&\n                currentResize.edges.bottom\n              ) {\n                snapGrid.y = +this.resizeSnapGrid.bottom;\n              }\n            }\n\n            return snapGrid;\n          };\n\n          function getGrid(\n            coords: { clientX: number; clientY: number },\n            snapGrid: Coordinate\n          ) {\n            return {\n              x: Math.ceil(coords.clientX / snapGrid.x),\n              y: Math.ceil(coords.clientY / snapGrid.y)\n            };\n          }\n\n          return merge(\n            mouseMove.pipe(take(1)).pipe(map(coords => [, coords])),\n            mouseMove.pipe(pairwise())\n          )\n            .pipe(\n              map(([previousCoords, newCoords]) => {\n                return [\n                  previousCoords ? getDiff(previousCoords) : previousCoords,\n                  getDiff(newCoords)\n                ];\n              })\n            )\n            .pipe(\n              filter(([previousCoords, newCoords]) => {\n                if (!previousCoords) {\n                  return true;\n                }\n\n                const snapGrid: Coordinate = getSnapGrid();\n                const previousGrid: Coordinate = getGrid(\n                  previousCoords,\n                  snapGrid\n                );\n                const newGrid: Coordinate = getGrid(newCoords, snapGrid);\n\n                return (\n                  previousGrid.x !== newGrid.x || previousGrid.y !== newGrid.y\n                );\n              })\n            )\n            .pipe(\n              map(([, newCoords]) => {\n                const snapGrid: Coordinate = getSnapGrid();\n                return {\n                  clientX:\n                    Math.round(newCoords.clientX / snapGrid.x) * snapGrid.x,\n                  clientY:\n                    Math.round(newCoords.clientY / snapGrid.y) * snapGrid.y\n                };\n              })\n            )\n            .pipe(takeUntil(merge(this.mouseup, this.mousedown)));\n        })\n      )\n      .pipe(filter(() => !!currentResize));\n\n    mousedrag\n      .pipe(\n        map(({ clientX, clientY }) => {\n          return getNewBoundingRectangle(\n            currentResize!.startingRect,\n            currentResize!.edges,\n            clientX,\n            clientY\n          );\n        })\n      )\n      .pipe(\n        filter((newBoundingRect: BoundingRectangle) => {\n          return !!(\n            newBoundingRect.height &&\n            newBoundingRect.width &&\n            newBoundingRect.height > 0 &&\n            newBoundingRect.width > 0\n          );\n        })\n      )\n      .pipe(\n        filter((newBoundingRect: BoundingRectangle) => {\n          return this.validateResize\n            ? this.validateResize({\n                rectangle: newBoundingRect,\n                edges: getEdgesDiff({\n                  edges: currentResize!.edges,\n                  initialRectangle: currentResize!.startingRect,\n                  newRectangle: newBoundingRect\n                })\n              })\n            : true;\n        })\n      )\n      .subscribe((newBoundingRect: BoundingRectangle) => {\n        if (currentResize && currentResize.clonedNode) {\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'height',\n            `${newBoundingRect.height}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'width',\n            `${newBoundingRect.width}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'top',\n            `${newBoundingRect.top}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'left',\n            `${newBoundingRect.left}px`\n          );\n        }\n\n        this.zone.run(() => {\n          this.resizing.emit({\n            edges: getEdgesDiff({\n              edges: currentResize!.edges,\n              initialRectangle: currentResize!.startingRect,\n              newRectangle: newBoundingRect\n            }),\n            rectangle: newBoundingRect\n          });\n        });\n\n        currentResize!.currentRect = newBoundingRect;\n      });\n\n    this.mousedown\n      .pipe(\n        map(({ clientX, clientY, edges }) => {\n          return (\n            edges ||\n            getResizeEdges({\n              clientX,\n              clientY,\n              elm: this.elm,\n              allowedEdges: this.resizeEdges,\n              cursorPrecision: this.resizeCursorPrecision\n            })\n          );\n        })\n      )\n      .pipe(\n        filter((edges: Edges) => {\n          return Object.keys(edges).length > 0;\n        })\n      )\n      .subscribe((edges: Edges) => {\n        if (currentResize) {\n          removeGhostElement();\n        }\n        const startingRect: BoundingRectangle = getElementRect(\n          this.elm,\n          this.ghostElementPositioning,\n          this.scaledParent,\n          this.scale\n        );\n        currentResize = {\n          edges,\n          startingRect,\n          currentRect: startingRect\n        };\n        if (this.enableGhostResize) {\n          currentResize.clonedNode = this.elm.nativeElement.cloneNode(true);\n          const resizeCursors: ResizeCursors = Object.assign(\n            {},\n            DEFAULT_RESIZE_CURSORS,\n            this.resizeCursors\n          );\n          this.elm.nativeElement.parentElement.appendChild(\n            currentResize.clonedNode\n          );\n          this.renderer.setStyle(\n            this.elm.nativeElement,\n            'visibility',\n            'hidden'\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'position',\n            this.ghostElementPositioning\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'left',\n            `${currentResize.startingRect.left}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'top',\n            `${currentResize.startingRect.top}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'height',\n            `${currentResize.startingRect.height}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'width',\n            `${currentResize.startingRect.width}px`\n          );\n          this.renderer.setStyle(\n            currentResize.clonedNode,\n            'cursor',\n            getResizeCursor(currentResize.edges, resizeCursors)\n          );\n          this.renderer.addClass(\n            currentResize.clonedNode,\n            RESIZE_GHOST_ELEMENT_CLASS\n          );\n          currentResize.clonedNode!.scrollTop = currentResize.startingRect\n            .scrollTop as number;\n          currentResize.clonedNode!.scrollLeft = currentResize.startingRect\n            .scrollLeft as number;\n        }\n        this.zone.run(() => {\n          this.resizeStart.emit({\n            edges: getEdgesDiff({\n              edges,\n              initialRectangle: startingRect,\n              newRectangle: startingRect\n            }),\n            rectangle: getNewBoundingRectangle(startingRect, {}, 0, 0)\n          });\n        });\n      });\n\n    this.mouseup.subscribe(() => {\n      if (currentResize) {\n        this.renderer.removeClass(this.elm.nativeElement, RESIZE_ACTIVE_CLASS);\n        this.renderer.setStyle(document.body, 'cursor', '');\n        this.renderer.setStyle(this.elm.nativeElement, 'cursor', '');\n        this.zone.run(() => {\n          this.resizeEnd.emit({\n            edges: getEdgesDiff({\n              edges: currentResize!.edges,\n              initialRectangle: currentResize!.startingRect,\n              newRectangle: currentResize!.currentRect\n            }),\n            rectangle: currentResize!.currentRect\n          });\n        });\n        removeGhostElement();\n        currentResize = null;\n      }\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  ngOnDestroy(): void {\n    this.mousedown.complete();\n    this.mouseup.complete();\n    this.mousemove.complete();\n    this.pointerEventListenerSubscriptions.pointerDown.unsubscribe();\n    this.pointerEventListenerSubscriptions.pointerMove.unsubscribe();\n    this.pointerEventListenerSubscriptions.pointerUp.unsubscribe();\n  }\n\n  private setElementClass(elm: ElementRef, name: string, add: boolean): void {\n    if (add) {\n      this.renderer.addClass(elm.nativeElement, name);\n    } else {\n      this.renderer.removeClass(elm.nativeElement, name);\n    }\n  }\n}\n\nclass PointerEventListeners {\n  public pointerDown: Observable<PointerEventCoordinate>;\n\n  public pointerMove: Observable<PointerEventCoordinate>;\n\n  public pointerUp: Observable<PointerEventCoordinate>;\n\n  private static instance: PointerEventListeners; // tslint:disable-line\n\n  public static getInstance(\n    renderer: Renderer2,\n    zone: NgZone\n  ): PointerEventListeners {\n    if (!PointerEventListeners.instance) {\n      PointerEventListeners.instance = new PointerEventListeners(\n        renderer,\n        zone\n      );\n    }\n    return PointerEventListeners.instance;\n  }\n\n  constructor(renderer: Renderer2, zone: NgZone) {\n    this.pointerDown = new Observable(\n      (observer: Observer<PointerEventCoordinate>) => {\n        let unsubscribeMouseDown: () => void;\n        let unsubscribeTouchStart: () => void;\n\n        zone.runOutsideAngular(() => {\n          unsubscribeMouseDown = renderer.listen(\n            'document',\n            'mousedown',\n            (event: MouseEvent) => {\n              observer.next({\n                clientX: event.clientX,\n                clientY: event.clientY,\n                event\n              });\n            }\n          );\n\n          unsubscribeTouchStart = renderer.listen(\n            'document',\n            'touchstart',\n            (event: TouchEvent) => {\n              observer.next({\n                clientX: event.touches[0].clientX,\n                clientY: event.touches[0].clientY,\n                event\n              });\n            }\n          );\n        });\n\n        return () => {\n          unsubscribeMouseDown();\n          unsubscribeTouchStart();\n        };\n      }\n    ).pipe(share());\n\n    this.pointerMove = new Observable(\n      (observer: Observer<PointerEventCoordinate>) => {\n        let unsubscribeMouseMove: () => void;\n        let unsubscribeTouchMove: () => void;\n\n        zone.runOutsideAngular(() => {\n          unsubscribeMouseMove = renderer.listen(\n            'document',\n            'mousemove',\n            (event: MouseEvent) => {\n              observer.next({\n                clientX: event.clientX,\n                clientY: event.clientY,\n                event\n              });\n            }\n          );\n\n          unsubscribeTouchMove = renderer.listen(\n            'document',\n            'touchmove',\n            (event: TouchEvent) => {\n              observer.next({\n                clientX: event.targetTouches[0].clientX,\n                clientY: event.targetTouches[0].clientY,\n                event\n              });\n            }\n          );\n        });\n\n        return () => {\n          unsubscribeMouseMove();\n          unsubscribeTouchMove();\n        };\n      }\n    ).pipe(share());\n\n    this.pointerUp = new Observable(\n      (observer: Observer<PointerEventCoordinate>) => {\n        let unsubscribeMouseUp: () => void;\n        let unsubscribeTouchEnd: () => void;\n        let unsubscribeTouchCancel: () => void;\n\n        zone.runOutsideAngular(() => {\n          unsubscribeMouseUp = renderer.listen(\n            'document',\n            'mouseup',\n            (event: MouseEvent) => {\n              observer.next({\n                clientX: event.clientX,\n                clientY: event.clientY,\n                event\n              });\n            }\n          );\n\n          unsubscribeTouchEnd = renderer.listen(\n            'document',\n            'touchend',\n            (event: TouchEvent) => {\n              observer.next({\n                clientX: event.changedTouches[0].clientX,\n                clientY: event.changedTouches[0].clientY,\n                event\n              });\n            }\n          );\n\n          unsubscribeTouchCancel = renderer.listen(\n            'document',\n            'touchcancel',\n            (event: TouchEvent) => {\n              observer.next({\n                clientX: event.changedTouches[0].clientX,\n                clientY: event.changedTouches[0].clientY,\n                event\n              });\n            }\n          );\n        });\n\n        return () => {\n          unsubscribeMouseUp();\n          unsubscribeTouchEnd();\n          unsubscribeTouchCancel();\n        };\n      }\n    ).pipe(share());\n  }\n}\n",
    "import {\n  Directive,\n  Input,\n  HostListener,\n  Renderer2,\n  ElementRef,\n  OnDestroy,\n  NgZone\n} from '@angular/core';\nimport { ResizableDirective } from './resizable.directive';\nimport { Edges } from './interfaces/edges.interface';\n\n/**\n * An element placed inside a `mwlResizable` directive to be used as a drag and resize handle\n *\n * For example\n *\n * ```html\n * <div mwlResizable>\n *   <div mwlResizeHandle [resizeEdges]=\"{bottom: true, right: true}\"></div>\n * </div>\n * ```\n */\n@Directive({\n  selector: '[mwlResizeHandle]'\n})\nexport class ResizeHandleDirective implements OnDestroy {\n  /**\n   * The `Edges` object that contains the edges of the parent element that dragging the handle will trigger a resize on\n   */\n  @Input() resizeEdges: Edges = {};\n\n  private eventListeners: {\n    touchmove?: () => void;\n    mousemove?: () => void;\n  } = {};\n\n  constructor(\n    private renderer: Renderer2,\n    private element: ElementRef,\n    private zone: NgZone,\n    private resizable: ResizableDirective\n  ) {}\n\n  ngOnDestroy(): void {\n    this.unsubscribeEventListeners();\n  }\n\n  /**\n   * @hidden\n   */\n  @HostListener('touchstart', [\n    '$event',\n    '$event.touches[0].clientX',\n    '$event.touches[0].clientY'\n  ])\n  @HostListener('mousedown', ['$event', '$event.clientX', '$event.clientY'])\n  onMousedown(\n    event: MouseEvent | TouchEvent,\n    clientX: number,\n    clientY: number\n  ): void {\n    event.preventDefault();\n    this.zone.runOutsideAngular(() => {\n      if (!this.eventListeners.touchmove) {\n        this.eventListeners.touchmove = this.renderer.listen(\n          this.element.nativeElement,\n          'touchmove',\n          (touchMoveEvent: TouchEvent) => {\n            this.onMousemove(\n              touchMoveEvent,\n              touchMoveEvent.targetTouches[0].clientX,\n              touchMoveEvent.targetTouches[0].clientY\n            );\n          }\n        );\n      }\n      if (!this.eventListeners.mousemove) {\n        this.eventListeners.mousemove = this.renderer.listen(\n          this.element.nativeElement,\n          'mousemove',\n          (mouseMoveEvent: MouseEvent) => {\n            this.onMousemove(\n              mouseMoveEvent,\n              mouseMoveEvent.clientX,\n              mouseMoveEvent.clientY\n            );\n          }\n        );\n      }\n      this.resizable.mousedown.next({\n        clientX,\n        clientY,\n        edges: this.resizeEdges\n      });\n    });\n  }\n\n  /**\n   * @hidden\n   */\n  @HostListener('touchend', [\n    '$event.changedTouches[0].clientX',\n    '$event.changedTouches[0].clientY'\n  ])\n  @HostListener('touchcancel', [\n    '$event.changedTouches[0].clientX',\n    '$event.changedTouches[0].clientY'\n  ])\n  @HostListener('mouseup', ['$event.clientX', '$event.clientY'])\n  onMouseup(clientX: number, clientY: number): void {\n    this.zone.runOutsideAngular(() => {\n      this.unsubscribeEventListeners();\n      this.resizable.mouseup.next({\n        clientX,\n        clientY,\n        edges: this.resizeEdges\n      });\n    });\n  }\n\n  private onMousemove(\n    event: MouseEvent | TouchEvent,\n    clientX: number,\n    clientY: number\n  ): void {\n    this.resizable.mousemove.next({\n      clientX,\n      clientY,\n      edges: this.resizeEdges,\n      event\n    });\n  }\n\n  private unsubscribeEventListeners(): void {\n    Object.keys(this.eventListeners).forEach(\n      (type: 'touchmove' | 'mousemove') => {\n        (this as any).eventListeners[type]();\n        delete this.eventListeners[type];\n      }\n    );\n  }\n}\n",
    "import { NgModule } from '@angular/core';\nimport { ResizableDirective } from './resizable.directive';\nimport { ResizeHandleDirective } from './resize-handle.directive';\n\n@NgModule({\n  declarations: [ResizableDirective, ResizeHandleDirective],\n  exports: [ResizableDirective, ResizeHandleDirective]\n})\nexport class ResizableModule {}\n"
  ],
  "names": [
    "precision",
    "Math",
    "abs",
    "value1",
    "value2",
    "getNewBoundingRectangle",
    "startingRect",
    "edges",
    "clientX",
    "clientY",
    "newBoundingRect",
    "top",
    "bottom",
    "left",
    "right",
    "height",
    "width",
    "isWithinBoundingY",
    "_a",
    "rect",
    "isWithinBoundingX",
    "getResizeEdges",
    "elm",
    "allowedEdges",
    "cursorPrecision",
    "elmPosition",
    "nativeElement",
    "getBoundingClientRect",
    "isNumberCloseTo",
    "DEFAULT_RESIZE_CURSORS",
    "Object",
    "freeze",
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight",
    "getResizeCursor",
    "cursors",
    "leftOrRight",
    "topOrBottom",
    "getEdgesDiff",
    "initialRectangle",
    "newRectangle",
    "edgesDiff",
    "keys",
    "forEach",
    "edge",
    "typedEdge",
    "RESIZE_ACTIVE_CLASS",
    "this",
    "zone",
    "resizeEdges",
    "resizeSnapGrid",
    "resizeCursors",
    "resizeCursorPrecision",
    "ghostElementPositioning",
    "scale",
    "resizeStart",
    "EventEmitter",
    "resizing",
    "resizeEnd",
    "mouseup",
    "Subject$1",
    "mousedown",
    "Subject",
    "ResizableDirective",
    "prototype",
    "ngOnInit",
    "_this",
    "pointerEventListenerSubscriptions",
    "pointerDown",
    "pointerEventListeners",
    "subscribe",
    "next",
    "pointerMove",
    "event",
    "mousemove",
    "pointerUp",
    "currentResize",
    "removeGhostElement",
    "clonedNode",
    "parentElement",
    "removeChild",
    "renderer",
    "setStyle",
    "mouseMove",
    "pipe",
    "share$1",
    "filter$1",
    "preventDefault",
    "throttle$1",
    "interval$1",
    "assign",
    "cursor",
    "document",
    "body",
    "setElementClass",
    "mergeMap$1",
    "startCoords",
    "getDiff",
    "moveCoords",
    "getSnapGrid",
    "snapGrid",
    "x",
    "y",
    "getGrid",
    "coords",
    "ceil",
    "merge$1",
    "take$1",
    "map$1",
    "pairwise$1",
    "previousCoords",
    "newCoords",
    "previousGrid",
    "newGrid",
    "round",
    "takeUntil$1",
    "validateResize",
    "rectangle",
    "run",
    "emit",
    "currentRect",
    "length",
    "element",
    "scaledParent",
    "translateX",
    "translateY",
    "style",
    "transform",
    "map",
    "property",
    "find",
    "value",
    "includes",
    "replace",
    "offsetHeight",
    "offsetWidth",
    "offsetTop",
    "offsetLeft",
    "boundingClientRect",
    "boundingRect",
    "parentClientRect",
    "scrollTop",
    "scrollLeft",
    "getElementRect",
    "enableGhostResize",
    "cloneNode",
    "appendChild",
    "addClass",
    "removeClass",
    "ngOnDestroy",
    "complete",
    "unsubscribe",
    "add",
    "name",
    "decorators",
    "type",
    "Directive",
    "args",
    "selector",
    "ctorParameters",
    "Renderer2",
    "NgZone",
    "Input",
    "PointerEventListeners",
    "Observable$1",
    "observer",
    "unsubscribeMouseDown",
    "unsubscribeTouchStart",
    "runOutsideAngular",
    "listen",
    "touches",
    "unsubscribeMouseMove",
    "unsubscribeTouchMove",
    "targetTouches",
    "unsubscribeMouseUp",
    "unsubscribeTouchEnd",
    "unsubscribeTouchCancel",
    "changedTouches",
    "ResizeHandleDirective",
    "resizable",
    "eventListeners",
    "unsubscribeEventListeners",
    "onMousedown",
    "mouseMoveEvent",
    "onMousemove",
    "onMouseup",
    "propDecorators",
    "HostListener"
  ],
  "mappings": "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"
}
